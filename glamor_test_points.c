#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <sys/types.h>
#include <time.h>
#include <sys/socket.h>

#include <xf86drm.h>
#include <xf86drmMode.h>
#include <gbm.h>

#define GL_GLEXT_PROTOTYPES 1
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#include <EGL/egl.h>
#include <EGL/eglext.h>
#include <GLES/egl.h>
#include <GLES/glext.h>

#define screenWidth (drm.mode->hdisplay)
#define screenHeght (drm.mode->vdisplay)
static int SHOW_FPS = 1;

static struct
{
  int fd;
  drmModeModeInfo *mode;
  uint32_t crtc_id;
  uint32_t connector_id;
} drm;

static struct
{
  struct gbm_device *dev;
  struct gbm_bo *bo;
} gbm;

struct drm_fb {
  struct gbm_bo *bo;
  uint32_t fb_id;
};

static struct
{
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
  GLuint vbo;
} gl;

static uint32_t
find_crtc_for_encoder(const drmModeRes *resources,
                      const drmModeEncoder *encoder)
{
  int i;

  for (i = 0; i < resources->count_crtcs; i++)
  {
    /* possible_crtcs is a bitmask as described here:
     * https://dvdhrm.wordpress.com/2012/09/13/linux-drm-mode-setting-api
     */
    const uint32_t crtc_mask = 1 << i;
    const uint32_t crtc_id = resources->crtcs[i];

    if (encoder->possible_crtcs & crtc_mask)
      return crtc_id;
  }

  /* no match found */
  return -1;
}

static uint32_t
find_crtc_for_connector(const drmModeRes *resources,
                        const drmModeConnector *connector)
{
  int i;

  for (i = 0; i < connector->count_encoders; i++)
  {
    const uint32_t encoder_id = connector->encoders[i];

    drmModeEncoder *encoder = drmModeGetEncoder(drm.fd, encoder_id);

    if (encoder)
    {
      const uint32_t crtc_id = find_crtc_for_encoder(resources, encoder);

      drmModeFreeEncoder(encoder);

      if (crtc_id)
        return crtc_id;
    }
  }

  /* no match found */
  return -1;
}

static int
init_drm(void)
{
  drmModeRes *resources;
  drmModeConnector *connector = NULL;
  drmModeEncoder *encoder = NULL;
  int i, area;

  drm.fd = open("/dev/dri/card1", O_RDWR);

  if (drm.fd < 0)
  {
    printf("could not open drm device\n");
    return -1;
  }

  fcntl(drm.fd, F_SETFD, fcntl(drm.fd, F_GETFD) | FD_CLOEXEC);
  resources = drmModeGetResources(drm.fd);

  if (!resources)
  {
    printf("drmModeGetResources failed: %s\n", strerror(errno));
    return -1;
  }

  /* find a connected connector: */
  for (i = 0; i < resources->count_connectors; i++)
  {
    connector = drmModeGetConnector(drm.fd, resources->connectors[i]);

    if (connector->connection == DRM_MODE_CONNECTED)
    {
      /* it's connected, let's use this! */
      break;
    }

    drmModeFreeConnector(connector);
    connector = NULL;
  }

  if (!connector)
  {
    /* we could be fancy and listen for hotplug events and wait for
                 * a connector..
                 */
    printf("no connected connector!\n");
    return -1;
  }

  /* find prefered mode or the highest resolution mode: */
  for (i = 0, area = 0; i < connector->count_modes; i++)
  {
    int current_area;

    drmModeModeInfo *current_mode = &connector->modes[i];

    if (current_mode->type & DRM_MODE_TYPE_PREFERRED)
      drm.mode = current_mode;

    current_area = current_mode->hdisplay * current_mode->vdisplay;

    if (current_area > area)
    {
      drm.mode = current_mode;
      area = current_area;
    }
  }

  if (!drm.mode)
  {
    printf("could not find mode!\n");
    return -1;
  }

  /* find encoder: */
  for (i = 0; i < resources->count_encoders; i++)
  {
    encoder = drmModeGetEncoder(drm.fd, resources->encoders[i]);

    if (encoder->encoder_id == connector->encoder_id)
      break;

    drmModeFreeEncoder(encoder);
    encoder = NULL;
  }

  if (encoder)
  {
    drm.crtc_id = encoder->crtc_id;
  }
  else
  {
    uint32_t crtc_id = find_crtc_for_connector(resources, connector);

    if (crtc_id == 0)
    {
      printf("no crtc found!\n");
      return -1;
    }

    drm.crtc_id = crtc_id;
  }

  drm.connector_id = connector->connector_id;

  return 0;
}

static int
init_gbm()
{
  gbm.dev = gbm_create_device(drm.fd);

  gbm.bo = gbm_bo_create(
        gbm.dev, drm.mode->hdisplay, drm.mode->vdisplay, GBM_FORMAT_ARGB8888,
        GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);

  if (!gbm.bo)
  {
    printf("failed to create gbm bo\n");
    return -1;
  }

  return 0;
}

static void
drm_fb_destroy_callback(struct gbm_bo *bo, void *data)
{
  struct drm_fb *fb = data;
  /*struct gbm_device *gbm = gbm_bo_get_device(bo);*/

  if (fb->fb_id)
    drmModeRmFB(drm.fd, fb->fb_id);

  free(fb);
}

static struct drm_fb *
drm_fb_get_from_bo(struct gbm_bo *bo)
{
  struct drm_fb *fb = gbm_bo_get_user_data(bo);
  uint32_t width, height, stride, handle;
  int ret;

  if (fb)
    return fb;

  fb = calloc(1, sizeof *fb);
  fb->bo = bo;

  width = gbm_bo_get_width(bo);
  height = gbm_bo_get_height(bo);
  stride = gbm_bo_get_stride(bo);
  handle = gbm_bo_get_handle(bo).u32;

  ret = drmModeAddFB(drm.fd, width, height, 24, 32, stride, handle, &fb->fb_id);

  if (ret)
  {
    printf("failed to create fb: %s\n", strerror(errno));
    free(fb);
    return NULL;
  }

  gbm_bo_set_user_data(bo, fb, drm_fb_destroy_callback);

  return fb;
}

PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
PFNGLEGLIMAGETARGETTEXTURE2DOESPROC _glEGLImageTargetTexture2DOES;
void GL_APIENTRY (*_glDiscardFramebufferEXT)(GLenum target, GLsizei numAttachments, const GLenum *attachments);
void GL_APIENTRY (*_glGenVertexArraysOES)(GLsizei n, GLuint *arrays);
void GL_APIENTRY (*_glBindVertexArrayOES)(GLuint array);
void GL_APIENTRY (*_glMapBufferOES)(GLenum target, GLenum access);

GLuint LoadShader(const char *shaderSrc, GLenum type)
{
  GLuint shader;
  GLint compiled;

  shader = glCreateShader(type);

  if(shader == 0)
    return 0;

  glShaderSource(shader, 1, &shaderSrc, NULL);
  glCompileShader(shader);
  glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);

  if(!compiled)
  {
    GLint infoLen = 0;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);

    if(infoLen > 1)
    {
      char* infoLog = malloc(sizeof(char) * infoLen);
      glGetShaderInfoLog(shader, infoLen, NULL, infoLog);
      printf("Error compiling shader:\n%s\n", infoLog);
      free(infoLog);
    }

    glDeleteShader(shader);
    return 0;
  }

  return shader;
}

GLuint
LoadProgram(const char *vertShaderSrc, const char *fragShaderSrc)
{
    GLuint vertexShader;
    GLuint fragmentShader;
    GLuint programObject;
    GLint linked;

    // Load the vertex/fragment shaders
    vertexShader = LoadShader(vertShaderSrc, GL_VERTEX_SHADER);
    if (vertexShader == 0)
        return 0;

    fragmentShader = LoadShader(fragShaderSrc, GL_FRAGMENT_SHADER);
    if (fragmentShader == 0)
    {
        glDeleteShader(vertexShader);
        return 0;
    }

    // Create the program object
    programObject = glCreateProgram();

    if (programObject == 0)
        return 0;

    glAttachShader(programObject, vertexShader);
    glAttachShader(programObject, fragmentShader);

    // Link the program
    glLinkProgram(programObject);

    // Check the link status
    glGetProgramiv(programObject, GL_LINK_STATUS, &linked);

    if (!linked)
    {
        GLint infoLen = 0;

        glGetProgramiv(programObject, GL_INFO_LOG_LENGTH, &infoLen);

        if (infoLen > 1)
        {
            char* infoLog = malloc(sizeof(char) * infoLen);

            glGetProgramInfoLog(programObject, infoLen, NULL, infoLog);
            printf("Error linking program:\n%s\n", infoLog);

            free(infoLog);
        }

        glDeleteProgram(programObject);
        return 0;
    }

    // Free up no longer needed shader resources
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    return programObject;
}

static int
init_gl(void)
{
  EGLint major, minor, n;

  static const EGLint context_attribs[] =
  {
    EGL_CONTEXT_CLIENT_VERSION, 2,
    EGL_NONE
  };

  static const EGLint config_attribs[] =
  {
    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
    EGL_NONE
  };

  PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display = NULL;
  get_platform_display =
      (void *) eglGetProcAddress("eglGetPlatformDisplayEXT");
  assert(get_platform_display != NULL);

  eglCreateImageKHR =
      (void *) eglGetProcAddress("eglCreateImageKHR");

  assert(eglCreateImageKHR != NULL);

  _glEGLImageTargetTexture2DOES =
      (void *) eglGetProcAddress("glEGLImageTargetTexture2DOES");

  assert(_glEGLImageTargetTexture2DOES != NULL);

  _glDiscardFramebufferEXT =
            (void *) eglGetProcAddress("glDiscardFramebufferEXT");

  _glGenVertexArraysOES =
      (void *) eglGetProcAddress("glGenVertexArraysOES");

  _glBindVertexArrayOES =
      (void *) eglGetProcAddress("glBindVertexArrayOES");

  _glMapBufferOES =
      (void *) eglGetProcAddress("glMapBufferOES");

  gl.display = get_platform_display(EGL_PLATFORM_GBM_KHR, gbm.dev, NULL);

  if (!eglInitialize(gl.display, &major, &minor))
  {
    fprintf(stderr, "failed to initialize\n");
    return -1;
  }

  if (!eglBindAPI(EGL_OPENGL_ES_API))
  {
    fprintf(stderr, "failed to bind api EGL_OPENGL_ES_API\n");
    return -1;
  }

  if (!eglChooseConfig(gl.display, config_attribs, &gl.config, 1, &n) || n != 1)
  {
    fprintf(stderr, "failed to choose config: %d\n", n);
    return -1;
  }

  gl.context = eglCreateContext(gl.display, gl.config,
                                EGL_NO_CONTEXT, context_attribs);
  if (gl.context == NULL)
  {
    fprintf(stderr, "failed to create context\n");
    return -1;
  }

  /* connect the context to the surface */
  eglMakeCurrent(gl.display, EGL_NO_SURFACE, EGL_NO_SURFACE, gl.context);

  return 0;
}

EGLImageKHR
image_from_bo(struct gbm_bo *bo)
{
  EGLImageKHR image;
  const EGLint attrib_list[] = {
    EGL_NONE
  };

  image = eglCreateImageKHR(gl.display, EGL_NO_CONTEXT,
                            EGL_NATIVE_PIXMAP_KHR, bo, attrib_list);

  return image;
}

GLuint
texture_from_image(EGLImageKHR image)
{
  GLuint textureId;

  glGenTextures(1, &textureId);
  glBindTexture(GL_TEXTURE_2D, textureId);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

  _glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, image);

  glBindTexture(GL_TEXTURE_2D, 0);

  return textureId;
}


GLuint bo_fbo = 0;
GLuint mainTex;

GLuint
texture_from_bo(struct gbm_bo *bo)
{
  return texture_from_image(image_from_bo(bo));
}


GLuint fbo_from_tex(GLuint _tex)
{
  GLuint fbo;

  glGenFramebuffers(1, &fbo);
  glBindFramebuffer(GL_FRAMEBUFFER, fbo);
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                         GL_TEXTURE_2D, _tex, 0);

  GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);

  if (status != GL_FRAMEBUFFER_COMPLETE)
      printf("Could not validate framebuffer\n");

  return fbo;
}

char white_vbo[] = {
  0x07,0x01,0xD9,0x01,0x08,0x01,0xD9,0x01,0x09,0x01,0xD9,0x01,0x0A,0x01,0xD9,0x01,
  0x13,0x01,0xD9,0x01,0x14,0x01,0xD9,0x01,0x15,0x01,0xD9,0x01,0x16,0x01,0xD9,0x01,
  0x07,0x01,0xDA,0x01,0x0B,0x01,0xDA,0x01,0x12,0x01,0xDA,0x01,0x16,0x01,0xDA,0x01,
  0x07,0x01,0xDB,0x01,0x0C,0x01,0xDB,0x01,0x11,0x01,0xDB,0x01,0x16,0x01,0xDB,0x01,
  0x07,0x01,0xDC,0x01,0x0D,0x01,0xDC,0x01,0x10,0x01,0xDC,0x01,0x16,0x01,0xDC,0x01,
  0x08,0x01,0xDD,0x01,0x0E,0x01,0xDD,0x01,0x0F,0x01,0xDD,0x01,0x15,0x01,0xDD,0x01,
  0x09,0x01,0xDE,0x01,0x14,0x01,0xDE,0x01,0x0A,0x01,0xDF,0x01,0x13,0x01,0xDF,0x01,
  0x0B,0x01,0xE0,0x01,0x12,0x01,0xE0,0x01,0x0B,0x01,0xE1,0x01,0x12,0x01,0xE1,0x01,
  0x0A,0x01,0xE2,0x01,0x13,0x01,0xE2,0x01,0x09,0x01,0xE3,0x01,0x14,0x01,0xE3,0x01,
  0x08,0x01,0xE4,0x01,0x0E,0x01,0xE4,0x01,0x0F,0x01,0xE4,0x01,0x15,0x01,0xE4,0x01,
  0x07,0x01,0xE5,0x01,0x0D,0x01,0xE5,0x01,0x10,0x01,0xE5,0x01,0x16,0x01,0xE5,0x01,
  0x07,0x01,0xE6,0x01,0x0C,0x01,0xE6,0x01,0x11,0x01,0xE6,0x01,0x16,0x01,0xE6,0x01,
  0x07,0x01,0xE7,0x01,0x0B,0x01,0xE7,0x01,0x12,0x01,0xE7,0x01,0x16,0x01,0xE7,0x01,
  0x07,0x01,0xE8,0x01,0x08,0x01,0xE8,0x01,0x09,0x01,0xE8,0x01,0x0A,0x01,0xE8,0x01,
  0x13,0x01,0xE8,0x01,0x14,0x01,0xE8,0x01,0x15,0x01,0xE8,0x01,0x16,0x01,0xE8,0x01,
  0x0E,0x01,0xE1,0x01,0x0F,0x01,0xE1,0x01,0x10,0x01,0xE1,0x01,0x11,0x01,0xE1,0x01,
  0x0B,0x01,0xE2,0x01,0x0C,0x01,0xE2,0x01,0x0D,0x01,0xE2,0x01,0x0E,0x01,0xE2,0x01,
  0x0F,0x01,0xE2,0x01,0x10,0x01,0xE2,0x01,0x11,0x01,0xE2,0x01,0x12,0x01,0xE2,0x01,
  0x0A,0x01,0xE3,0x01,0x0B,0x01,0xE3,0x01,0x0C,0x01,0xE3,0x01,0x0D,0x01,0xE3,0x01,
  0x0E,0x01,0xE3,0x01,0x0F,0x01,0xE3,0x01,0x10,0x01,0xE3,0x01,0x11,0x01,0xE3,0x01,
  0x12,0x01,0xE3,0x01,0x13,0x01,0xE3,0x01,0x09,0x01,0xE4,0x01,0x0A,0x01,0xE4,0x01,
  0x0B,0x01,0xE4,0x01,0x0C,0x01,0xE4,0x01,0x0D,0x01,0xE4,0x01,0x10,0x01,0xE4,0x01,
  0x11,0x01,0xE4,0x01,0x12,0x01,0xE4,0x01,0x13,0x01,0xE4,0x01,0x14,0x01,0xE4,0x01,
  0x08,0x01,0xE5,0x01,0x09,0x01,0xE5,0x01,0x0A,0x01,0xE5,0x01,0x0B,0x01,0xE5,0x01,
  0x0C,0x01,0xE5,0x01,0x11,0x01,0xE5,0x01,0x12,0x01,0xE5,0x01,0x13,0x01,0xE5,0x01,
  0x14,0x01,0xE5,0x01,0x15,0x01,0xE5,0x01,0x08,0x01,0xE6,0x01,0x09,0x01,0xE6,0x01,
  0x0A,0x01,0xE6,0x01,0x0B,0x01,0xE6,0x01,0x12,0x01,0xE6,0x01,0x13,0x01,0xE6,0x01,
  0x14,0x01,0xE6,0x01,0x15,0x01,0xE6,0x01,0x08,0x01,0xE7,0x01,0x09,0x01,0xE7,0x01,
  0x0A,0x01,0xE7,0x01,0x13,0x01,0xE7,0x01,0x14,0x01,0xE7,0x01,0x15,0x01,0xE7,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

char black_vbo[] =
{
  0x08,0x01,0xDA,0x01,0x09,0x01,0xDA,0x01,0x0A,0x01,0xDA,0x01,0x13,0x01,0xDA,0x01,
  0x14,0x01,0xDA,0x01,0x15,0x01,0xDA,0x01,0x08,0x01,0xDB,0x01,0x09,0x01,0xDB,0x01,
  0x0A,0x01,0xDB,0x01,0x0B,0x01,0xDB,0x01,0x12,0x01,0xDB,0x01,0x13,0x01,0xDB,0x01,
  0x14,0x01,0xDB,0x01,0x15,0x01,0xDB,0x01,0x08,0x01,0xDC,0x01,0x09,0x01,0xDC,0x01,
  0x0A,0x01,0xDC,0x01,0x0B,0x01,0xDC,0x01,0x0C,0x01,0xDC,0x01,0x11,0x01,0xDC,0x01,
  0x12,0x01,0xDC,0x01,0x13,0x01,0xDC,0x01,0x14,0x01,0xDC,0x01,0x15,0x01,0xDC,0x01,
  0x09,0x01,0xDD,0x01,0x0A,0x01,0xDD,0x01,0x0B,0x01,0xDD,0x01,0x0C,0x01,0xDD,0x01,
  0x0D,0x01,0xDD,0x01,0x10,0x01,0xDD,0x01,0x11,0x01,0xDD,0x01,0x12,0x01,0xDD,0x01,
  0x13,0x01,0xDD,0x01,0x14,0x01,0xDD,0x01,0x0A,0x01,0xDE,0x01,0x0B,0x01,0xDE,0x01,
  0x0C,0x01,0xDE,0x01,0x0D,0x01,0xDE,0x01,0x0E,0x01,0xDE,0x01,0x0F,0x01,0xDE,0x01,
  0x10,0x01,0xDE,0x01,0x11,0x01,0xDE,0x01,0x12,0x01,0xDE,0x01,0x13,0x01,0xDE,0x01,
  0x0B,0x01,0xDF,0x01,0x0C,0x01,0xDF,0x01,0x0D,0x01,0xDF,0x01,0x0E,0x01,0xDF,0x01,
  0x0F,0x01,0xDF,0x01,0x10,0x01,0xDF,0x01,0x11,0x01,0xDF,0x01,0x12,0x01,0xDF,0x01,
  0x0C,0x01,0xE0,0x01,0x0D,0x01,0xE0,0x01,0x0E,0x01,0xE0,0x01,0x0F,0x01,0xE0,0x01,
  0x10,0x01,0xE0,0x01,0x11,0x01,0xE0,0x01,0x0C,0x01,0xE1,0x01,0x0D,0x01,0xE1,0x01,
  0x0E,0x01,0xE1,0x01,0x0F,0x01,0xE1,0x01,0x10,0x01,0xE1,0x01,0x11,0x01,0xE1,0x01,
  0x0B,0x01,0xE2,0x01,0x0C,0x01,0xE2,0x01,0x0D,0x01,0xE2,0x01,0x0E,0x01,0xE2,0x01,
  0x0F,0x01,0xE2,0x01,0x10,0x01,0xE2,0x01,0x11,0x01,0xE2,0x01,0x12,0x01,0xE2,0x01,
  0x0A,0x01,0xE3,0x01,0x0B,0x01,0xE3,0x01,0x0C,0x01,0xE3,0x01,0x0D,0x01,0xE3,0x01,
  0x0E,0x01,0xE3,0x01,0x0F,0x01,0xE3,0x01,0x10,0x01,0xE3,0x01,0x11,0x01,0xE3,0x01,
  0x12,0x01,0xE3,0x01,0x13,0x01,0xE3,0x01,0x09,0x01,0xE4,0x01,0x0A,0x01,0xE4,0x01,
  0x0B,0x01,0xE4,0x01,0x0C,0x01,0xE4,0x01,0x0D,0x01,0xE4,0x01,0x10,0x01,0xE4,0x01,
  0x11,0x01,0xE4,0x01,0x12,0x01,0xE4,0x01,0x13,0x01,0xE4,0x01,0x14,0x01,0xE4,0x01,
  0x08,0x01,0xE5,0x01,0x09,0x01,0xE5,0x01,0x0A,0x01,0xE5,0x01,0x0B,0x01,0xE5,0x01,
  0x0C,0x01,0xE5,0x01,0x11,0x01,0xE5,0x01,0x12,0x01,0xE5,0x01,0x13,0x01,0xE5,0x01,
  0x14,0x01,0xE5,0x01,0x15,0x01,0xE5,0x01,0x08,0x01,0xE6,0x01,0x09,0x01,0xE6,0x01,
  0x0A,0x01,0xE6,0x01,0x0B,0x01,0xE6,0x01,0x12,0x01,0xE6,0x01,0x13,0x01,0xE6,0x01,
  0x14,0x01,0xE6,0x01,0x15,0x01,0xE6,0x01,0x08,0x01,0xE7,0x01,0x09,0x01,0xE7,0x01,
  0x0A,0x01,0xE7,0x01,0x13,0x01,0xE7,0x01,0x14,0x01,0xE7,0x01,0x15,0x01,0xE7,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

static GLuint vbo;
static GLuint vao;

void
init_vbo()
{
  if (!vbo)
  {
    glGenBuffers(1 ,&vbo);

    _glGenVertexArraysOES(1, &vao);
    _glBindVertexArrayOES(vao);
  }
}

static void
calc_pos(float width, float height, float x, float y, float *fx, float *fy)
{
  *fx = 1 - 2 * (x / width);
  *fy = 1 - 2 * (y / height);
}

static void
calc_cursor_pos(float width, float height, float x, float y, float *fx, float *fy)
{
  *fx = 2.0f * (x / width - 1.0f);
  *fy = 2.0f * (y / height - 1.0f);
}

static void
calc_size(float width, float height, float *fx, float *fy)
{
  *fx = 2.0f / width;
  *fy = 2.0f / height;
}

static void
copy_tex(GLuint src_tex, float src_x1, float src_y1, float src_w, float src_h,
         GLuint dst_fbo, float dst_x1, float dst_y1, float dst_x2, float dst_y2)
{
  static GLuint copy_area;
  static GLuint fill_offset;
  static GLuint fill_size_inv;
  static GLuint v_matrix;

  if (!copy_area)
  {
    copy_area = LoadProgram(
          "attribute vec2 primitive;\n"
          "uniform vec2 fill_offset;\n"
          "uniform vec2 fill_size_inv;\n"
          "varying vec2 fill_pos;\n"
          "uniform vec4 v_matrix;\n"
          "void main() {\n"
          "       gl_Position.xy = primitive.xy * v_matrix.xz + v_matrix.yw;\n"
          "       gl_Position.zw = vec2(0.0,1.0);\n"
          "       fill_pos = (fill_offset + primitive.xy) * fill_size_inv;\n"
          "}\n",
          "#ifdef GL_ES\n"
          "precision mediump float;\n"
          "#endif\n"
          "uniform sampler2D sampler;\n"
          "varying vec2 fill_pos;\n"
          "void main() {\n"
          "        gl_FragColor = texture2D(sampler, fill_pos);\n"
          "}\n");

    glBindAttribLocation(copy_area, 0, "primitive");
    v_matrix = glGetUniformLocation(copy_area,"v_matrix");
    fill_offset = glGetUniformLocation(copy_area,"fill_offset");
    fill_size_inv = glGetUniformLocation(copy_area,"fill_size_inv");
  }

  float dst_w = dst_x2 - dst_x1;
  float dst_h = dst_y2 - dst_y1;

  GLshort data[] = {
    dst_x1, dst_y1,
    dst_x1, dst_y2,
    dst_x2, dst_y2,
    dst_x2, dst_y1
  };

  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, 2, GL_SHORT, GL_FALSE, 0, NULL);
  glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STREAM_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glEnable(GL_SCISSOR_TEST);

  glUseProgram(copy_area);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, src_tex);

  float x, y, z, w;

  calc_pos(dst_w, dst_h, dst_w, dst_h, &y, &w);
  calc_size(dst_w, dst_h, &x, &z);

  glUniform4f(v_matrix, x, y, z, w);

  glUniform2f(fill_offset, src_x1, src_y1);
  glUniform2f(fill_size_inv, 1.0 / src_w, 1.0 / src_h);

  glBindFramebuffer(GL_FRAMEBUFFER, dst_fbo);
  glViewport(dst_x1, dst_y1, dst_x2, dst_y2);
  glScissor(dst_x1, dst_y1, dst_x2, dst_y2);

  glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

  glDisable(GL_SCISSOR_TEST);
  glDisableVertexAttribArray(0);
}

static void
save_under_cursor(float x, float y)
{

  static GLuint save_tex;
  static GLuint save_fbo;

  if(!save_tex)
  {
    glGenTextures(1, &save_tex);

    glBindTexture(GL_TEXTURE_2D, save_tex);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,GL_NEAREST);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_BGRA_EXT, 32, 32, 0, GL_BGRA_EXT,
                 GL_UNSIGNED_BYTE, NULL);

    glBindTexture(GL_TEXTURE_2D, 0);

    save_fbo = fbo_from_tex(save_tex);

  }

  copy_tex(mainTex, x - 16, y - 16, screenWidth, screenHeght,
           save_fbo, 0, 0, 32, 32);

/*  glPixelStorei(GL_PACK_ALIGNMENT, 4);

  char buf[32 * 32 * 4] = {0};
  glReadPixels(0, 0, 32, 32, GL_BGRA_EXT, GL_UNSIGNED_BYTE, buf);*/
  /*printf("%x %x %x %x\n",buf[0],buf[1],buf[2],buf[3]);*/
}

void
draw_pixels(GLuint fbo, const GLfloat v_m[4], const GLfloat color[4],
            void *data, int data_size, int num_points)
{
  static GLuint poly_glyph_blt_solid = 0;
  static GLuint v_matrix;
  static GLuint fg;

  if (!poly_glyph_blt_solid)
  {
    poly_glyph_blt_solid = LoadProgram(
          "attribute vec2 primitive;\n"
          "uniform vec4 v_matrix;\n"
          "void main() {\n"
          "#ifdef GL_ES\n"
          "gl_PointSize = 1.0;\n"
          "#endif\n"
          "       gl_Position.xy = primitive.xy * v_matrix.xz + v_matrix.yw;\n"
          "       gl_Position.zw = vec2(0.0,1.0);\n"
          "}\n",
          "#ifdef GL_ES\n"
          "precision mediump float;\n"
          "#endif\n"
          "uniform vec4 fg;\n"
          "void main() {\n"
          "       gl_FragColor = fg;\n"
          "}\n");

    glBindAttribLocation(poly_glyph_blt_solid, 0, "primitive");
    v_matrix = glGetUniformLocation(poly_glyph_blt_solid , "v_matrix");
    fg = glGetUniformLocation(poly_glyph_blt_solid , "fg");
  }

  glUseProgram(poly_glyph_blt_solid);

  glUniform4fv(fg, 1, color);

  glEnableVertexAttribArray(0);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 2, GL_SHORT, GL_FALSE, 0, NULL);

  glBufferData(GL_ARRAY_BUFFER, data_size, data, GL_STREAM_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glUniform4f(v_matrix, v_m[0], v_m[1], v_m[2], v_m[3]);

  glBindFramebuffer(GL_FRAMEBUFFER, fbo);
  glViewport(0, 0, screenWidth, screenHeght);
  glDrawArrays(GL_POINTS, 0, num_points);

  glDisableVertexAttribArray(0);
}

static void
draw_cursor(float x, float y)
{
  GLfloat black[] = {0.0f, 0.0f, 0.0f, 1.0f};
  GLfloat white[] = {1.0f, 1.0f, 1.0f, 1.0f};

  float pos[4];

  calc_size(screenWidth, screenHeght, &pos[0], &pos[2]);
  calc_cursor_pos(screenWidth, screenHeght, x, y, &pos[1], &pos[3]);

  draw_pixels(bo_fbo, pos, black, black_vbo, sizeof(black_vbo), 116);
  draw_pixels(bo_fbo, pos, white, white_vbo, sizeof(white_vbo), 60);
}

static void
draw_background(GLuint fbo)
{
  static GLuint poly_fill_rect_tile;
  static GLuint fill_offset;
  static GLuint fill_size_inv;
  static GLuint v_matrix;
  static GLuint tile_tex;
  static GLuint tile_fbo;

  if (!poly_fill_rect_tile)
  {
    glGenTextures(1, &tile_tex);
    glBindTexture(GL_TEXTURE_2D, tile_tex);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_BGRA_EXT, 4, 4, 0, GL_BGRA_EXT,
                 GL_UNSIGNED_BYTE, NULL);

    tile_fbo = fbo_from_tex(tile_tex);

    poly_fill_rect_tile = LoadProgram(
          "attribute vec2 primitive;\n"
          "uniform vec2 fill_offset;\n"
          "uniform vec2 fill_size_inv;\n"
          "varying vec2 fill_pos;\n"
          "uniform vec4 v_matrix;\n"
          "void main() {\n"
          "        vec2 pos = vec2(0,0);\n"
          "       gl_Position.xy = primitive.xy * v_matrix.xz + v_matrix.yw;\n"
          "       gl_Position.zw = vec2(0.0,1.0);\n"
          "       fill_pos = (fill_offset + primitive.xy + pos) * fill_size_inv;\n"
          "}\n",
          "#ifdef GL_ES\n"
          "precision mediump float;\n"
          "#endif\n"
          "uniform sampler2D sampler;\n"
          "varying vec2 fill_pos;\n"
          "void main() {\n"
          "       gl_FragColor = texture2D(sampler, fill_pos);\n"
          "}\n");
    glBindAttribLocation(poly_fill_rect_tile, 0, "primitive");
    v_matrix = glGetUniformLocation(poly_fill_rect_tile,"v_matrix");
    fill_offset = glGetUniformLocation(poly_fill_rect_tile,"fill_offset");
    fill_size_inv = glGetUniformLocation(poly_fill_rect_tile,"fill_size_inv");
  }

  char buf[4 * 4 * 4] = {0};

  glPixelStorei(GL_PACK_ALIGNMENT,4);
  glBindFramebuffer(GL_FRAMEBUFFER,tile_fbo);
  glReadPixels(0, 0, 4, 4, GL_BGRA_EXT, GL_UNSIGNED_BYTE, buf);

  glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, tile_tex);

  struct {
    struct {
      uint32_t p;
    }
    col[4];
  }row[4];

  memset(row, 0x7F, sizeof(row));

  row[1].col[1].p = 0xFF;
  row[1].col[2].p = 0xFF;
  row[2].col[1].p = 0xFF;
  row[3].col[2].p = 0xFF;

  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 4, 4, GL_BGRA_EXT, GL_UNSIGNED_BYTE,
                  row);


  glUseProgram(poly_fill_rect_tile);
  glUniform2f(fill_offset, 0.000000, 0.000000);
  glUniform2f(fill_size_inv, 0.250000, 0.250000);

  glEnableVertexAttribArray(0);
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glVertexAttribPointer(0, 2, GL_SHORT, GL_FALSE, 4, NULL);

  GLshort data[] = {0, 0,
                    0, screenHeght,
                    screenWidth, screenHeght,
                    screenWidth, 0};
  glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_DYNAMIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glEnable(GL_SCISSOR_TEST);

  glUniform4f(v_matrix, 0.003704, -1.000000, 0.002083, -1.000000);
  glBindFramebuffer(GL_FRAMEBUFFER, fbo);
  glViewport(0, 0, screenWidth, screenHeght);
  glScissor(0, 0, screenWidth, screenHeght);

  glDrawArrays(GL_TRIANGLE_FAN ,0 ,4);

  glDisable(GL_SCISSOR_TEST);
  glDisableVertexAttribArray(0);
}

static uint32_t
TimeElapsedMs(const struct timespec *tStartTime,
              const struct timespec *tEndTime)
{
  return 1000 * (tEndTime->tv_sec - tStartTime->tv_sec) +
      (tEndTime->tv_nsec - tStartTime->tv_nsec) / 1000000;
}

static void
CalculateFrameRate()
{
  static float framesPerSecond    = 0.0f;       // This will store our fps
  static struct timespec lastTime;
  static struct timespec currentTime;
  static int firstTime = 1;

  clock_gettime(CLOCK_MONOTONIC, &currentTime);

  if (firstTime)
  {
    lastTime = currentTime;
    firstTime = 0;
  }

  framesPerSecond++;

  if (TimeElapsedMs(&lastTime, &currentTime) > 1000)
  {
    lastTime = currentTime;

    if (SHOW_FPS == 1)
    {
      fprintf(stderr, "\nCurrent Frames Per Second: %d\n\n",
              (int)(framesPerSecond / 1.0f));
    }

    framesPerSecond = 0;
  }
}

int
main(int argc, char *argv[])
{
  int ret;
  struct drm_fb *fb;

  if ((ret = init_drm()))
  {
    fprintf(stdout, "failed to initialize DRM\n");
    return ret;
  }

  if ((ret = init_gbm()))
  {
    fprintf(stdout, "failed to initialize GBM\n");
    return ret;
  }

  if ((ret = init_gl()))
  {
    fprintf(stdout, "failed to initialize EGL\n");
    return ret;
  }

  fb = drm_fb_get_from_bo(gbm.bo);

  mainTex = texture_from_bo(gbm.bo);
  bo_fbo = fbo_from_tex(mainTex);

  /* set mode: */
  ret = drmModeSetCrtc(drm.fd, drm.crtc_id, fb->fb_id, 0, 0,
                       &drm.connector_id, 1, drm.mode);
  if (ret)
  {
          fprintf(stdout, "failed to set mode: %s\n", strerror(errno));
          return ret;
  }

  init_vbo();

  draw_background(bo_fbo);

#define BUF_W screenWidth
#define BUF_H screenHeght

  float x = 100, y = 100;
  char buf[BUF_W*BUF_H*4];
  memset(buf, 128, sizeof(buf));

  GLuint tmp_tex;
  glGenTextures(1, &tmp_tex);
  glBindTexture(GL_TEXTURE_2D, tmp_tex);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_BGRA_EXT, screenWidth, screenHeght, 0,
               GL_BGRA_EXT, GL_UNSIGNED_BYTE, NULL);

  while(1)
  {

    save_under_cursor(x, y);
    glFlush();

    glBindTexture(GL_TEXTURE_2D, tmp_tex);
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, BUF_W, BUF_H, GL_BGRA_EXT,
                    GL_UNSIGNED_BYTE, buf);
    glBindTexture(GL_TEXTURE_2D, 0);

    copy_tex(tmp_tex, 0, 0, screenWidth, screenHeght,
             bo_fbo, 0, 0, BUF_W, BUF_H);

    draw_cursor(x, y);

    CalculateFrameRate();
  }

  return ret;
}
